<?php

/**
 * Products
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Products extends BaseProducts
{
  public function setUp() {
    parent::setUp();
    $this->hasMany('Families as families', array(
        'local' => 'idProduct',
        'foreign' => 'idFamily',
        'refClass' => 'ProductsFamilies'
      )
    );
    $this->hasMany('ReferencesContent as references', array(
        'local' => 'id',
        'foreign' => 'idProduct'
      )
    );
    $this->hasOne('ReferencesCols as ref_headers', array(
        'local' => 'id',
        'foreign' => 'idProduct'
      )
    );
    $this->hasOne('Advertisers as advertiser', array(
        'local' => 'idAdvertiser',
        'foreign' => 'id'
      )
    );
    $this->hasOne('ProductsFr as product_fr', array(
        'local' => 'id',
        'foreign' => 'id'
      )
    );
    $this->hasOne('ProductsStats as product_stats', array(
        'local' => 'id',
        'foreign' => 'id'
      )
    );
    $this->hasMany('ProductsRelated as products_related', array(
        'local' => 'id',
        'foreign' => 'pdt_id'
      )
    );
    $this->hasOne('ProductsRelated as products_related_to', array(
        'local' => 'id',
        'foreign' => 'pdt_related_id'
      )
    );
    $this->hasMany('ProductsLinked as products_linked', array(
        'local' => 'id',
        'foreign' => 'pdt_id'
      )
    );
    $this->hasOne('ProductsLinked as products_linked_to', array(
        'local' => 'id',
        'foreign' => 'pdt_linked_id'
      )
    );
    $this->hasMany('ProductAttribute as product_attributes', array(
        'local' => 'id',
        'foreign' => 'product_id'
      )
    );
  }

  const SHOWN_PRODUCTS_RELATED_COUNT = 5;
  const PERTAINED_PRODUCTS_RELATED_COUNT = 20;

  private static $sCatList;  // categories stats cache (0 = every cats)
  private static $statsKeys; // key stats names cache

  // Arbitrary user weight
  // ----------------------------------------
  // Performance weight
  const HITS2LEADS_W = 0.2;  // weight of products leads
  const HITS2ORDERS_W = 0.8; // weight of products orders

  // Category performance relative weight
  const GLOBAL_W = 0.8; // weight of the global(whole db) average hits/orders/...
  const CAT1_W = 2.0;   // same for cat 1
  const CAT2_W = 0.8;   // for cat 2
  const CAT3_W = 0.4;   // for cat 3

  // Frequency weight if 2 times more
  const HITS_FREQ_W2 = 1.1;     // 2 times more hits than average = 10% more weight
  const HITS_DAY_FREQ_W2 = 1.2; // same for hits per day (ex: 20%)

  // Frequency for a category = it's relative part in the whole db
  const CAT1_FREQ_W2 = 1.1; // weight of a cat1 frequency relative to the average ; ex: if 2 times the average frequency, 10% more weight (1.1)
  const CAT2_FREQ_W2 = 1.1; // same for cat 2
  const CAT3_FREQ_W2 = 1.1; // for cat 3

  // math power to use
  const HITS_FREQ_W2P = 0.13750352374993502;    // log(HITS_FREQ_W2, 2)
  const HITS_DAY_FREQ_W2P = 0.2630344058337938; // log(HITS_DAY_FREQ_W2, 2)
  const CAT1_FREQ_W2P = 0.13750352374993502;    // log(CAT1_FREQ_W2, 2)
  const CAT2_FREQ_W2P = 0.13750352374993502;    // log(CAT2_FREQ_W2, 2)
  const CAT3_FREQ_W2P = 0.13750352374993502;    // log(CAT3_FREQ_W2, 2)

  // normalisation to 1 coefs ( CAT1_FREQ_N * pow(AVG_STAT_PART_IN_CAT1, CAT1_FREQ_W2P) = 1 )
  private static $CAT1_FREQ_N;
  private static $CAT2_FREQ_N;
  private static $CAT3_FREQ_N;

  public static function setProductsPerformanceScore(&$pdtList) {
    $dom = Families::getDomXML();
    $xPath = Families::getXPathXML();
    $sCatList = self::$sCatList;

    $sCat0 = &self::$sCatList[0];
    if (!isset($sCat0)) {
      $xmlCat0 = $xPath->query("parent::categories",$dom->getElementById(XML_KEY_PREFIX."0"))->item(0);
      self::$statsKeys = explode("|",$xPath->query("child::stats_key",$xmlCat0)->item(0)->nodeValue);
      $stats = explode("|",$xPath->query("child::stats",$xmlCat0)->item(0)->nodeValue);
      for ($sk=0, $slen=count($stats); $sk < $slen; $sk++)
        $sCat0[self::$statsKeys[$sk]] = $stats[$sk];

      $sCat0['hits_avg'] = $sCat0['hits'] / $sCat0['pdt_count'];
      $sCat0['leads_avg'] = $sCat0['leads'] / $sCat0['pdt_count'];
      $sCat0['orders_avg'] = $sCat0['orders'] / $sCat0['pdt_count'];
      $sCat0['hpd_avg'] = ($sCat0['hits'] / $sCat0['age_avg'] * 86400) / $sCat0['pdt_count'];

      self::$CAT1_FREQ_N = pow((int)$sCat0['cat1_count'], self::CAT1_FREQ_W2P);
      self::$CAT2_FREQ_N = pow((int)$sCat0['cat2_count'], self::CAT2_FREQ_W2P);
      self::$CAT3_FREQ_N = pow((int)$sCat0['cat3_count'], self::CAT3_FREQ_W2P);
    }

    foreach ($pdtList as &$pdt) {

      $cat3ID = isset($pdt['catID']) ? $pdt['catID'] : (
        isset($pdt['cat3ID']) ? $pdt['cat3ID'] : (
          isset($pdt['cat_id']) ? $pdt['cat_id'] : (
            isset($pdt['cat3_id']) ? $pdt['cat3_id'] :
              $pdt['idFamily']
          )
        )
      );
      if (!isset($cat3ID))
        continue;

      // check we have hits 2 leads stat
      if (!isset($pdt['hits2leads'])) {
        if (isset($pdt['hits']) && isset($pdt['leads']))
          $pdt['hits2leads'] = $pdt['hits'] > 0 ? $pdt['leads'] / $pdt['hits'] : 0;
        else
          continue;
      }

      // same for hits 2 orders
      if (!isset($pdt['hits2orders'])) {
        if (isset($pdt['hits']) && isset($pdt['orders']))
          $pdt['hits2orders'] = $pdt['hits'] > 0 ? $pdt['orders'] / $pdt['hits'] : 0;
        else
          continue;
      }

      // same for hits per day
      if (!isset($pdt['hpd'])) {
        $timeSinceFirstHit = mktime(0,0,0) - $pdt['first_hit_time'];
        if (isset($pdt['hits']) && isset($pdt['first_hit_time']))
          $pdt['hpd'] = $timeSinceFirstHit > 0 ? $pdt['hits'] / $timeSinceFirstHit * 86400 : 0;
        else
          continue;
      }

      $sCat3 = &self::$sCatList[$cat3ID];
      if (!isset($sCat3)) { // cat3 not in cache
        // find node
        $xmlCat3Id = $dom->getElementById(XML_KEY_PREFIX.$cat3ID);
        if (!isset($xmlCat3Id))
          continue;
        $xmlCat3 = $xPath->query("parent::category",$xmlCat3Id)->item(0);
        if (!isset($xmlCat3))
          continue;

        // get stats
        $stats = explode("|",$xPath->query("child::stats",$xmlCat3)->item(0)->nodeValue);
        for ($sk=0, $slen=count($stats); $sk < $slen; $sk++)
          $sCat3[self::$statsKeys[$sk]] = $stats[$sk];

        // precalc stats
        $sCat3['hits_avg'] = $sCat3['hits'] / $sCat3['pdt_count'];
        $sCat3['leads_avg'] = $sCat3['leads'] / $sCat3['pdt_count'];
        $sCat3['orders_avg'] = $sCat3['orders'] / $sCat3['pdt_count'];
        $sCat3['hpd_avg'] = ($sCat3['hits'] / $sCat3['age_avg'] * 86400) / $sCat3['pdt_count'];

        // get cat3 parents
        $catTree = $xPath->query("ancestor-or-self::category", $xmlCat3);

        // cat1
        $xmlCat1 = $catTree->item(0);
        $cat1ID = $xmlCat1->getAttribute('id');
        $sCat1 = &self::$sCatList[$cat1ID];

        // cat2
        $xmlCat2 = $catTree->item(1);
        $cat2ID = $xmlCat2->getAttribute('id');
        $sCat2 = &self::$sCatList[$cat2ID];

        // get cat1 stats if not in cache
        if (!isset($sCat1)) {
          $stats = explode("|",$xPath->query("child::stats",$xmlCat1)->item(0)->nodeValue);
          for ($sk=0, $slen=count($stats); $sk < $slen; $sk++)
            $sCat1[self::$statsKeys[$sk]] = $stats[$sk];

          $sCat1['hits_avg'] = $sCat1['hits'] / $sCat1['pdt_count'];
          $sCat1['leads_avg'] = $sCat1['leads'] / $sCat1['pdt_count'];
          $sCat1['orders_avg'] = $sCat1['orders'] / $sCat1['pdt_count'];
          $sCat1['hpd_avg'] = ($sCat1['hits'] / $sCat1['age_avg'] * 86400) / $sCat1['pdt_count'];
        }

        // get cat2 stats if not in cache
        if (!isset($sCat2)) {
          $stats = explode("|",$xPath->query("child::stats",$xmlCat2)->item(0)->nodeValue);
          for ($sk=0, $slen=count($stats); $sk < $slen; $sk++)
            $sCat2[self::$statsKeys[$sk]] = $stats[$sk];

          $sCat2['hits_avg'] = $sCat2['hits'] / $sCat2['pdt_count'];
          $sCat2['leads_avg'] = $sCat2['leads'] / $sCat2['pdt_count'];
          $sCat2['orders_avg'] = $sCat2['orders'] / $sCat2['pdt_count'];
          $sCat2['hpd_avg'] = ($sCat2['hits'] / $sCat2['age_avg'] * 86400) / $sCat2['pdt_count'];
        }

        // Computation :
        // ----------------------------------------
        // We calculate an "average" hits/orders/... per product using a lot of weighted coefficient computed from
        // the whole db (global), and the relative size of the current cat1, cat2 and cat3
        // k0 k1 k2 k3 = arbitrary coef * computed relative size coef
        // for hits :
        $h_k0 = self::GLOBAL_W;
        $h_k1 = self::CAT1_W * self::$CAT1_FREQ_N * pow($sCat1['hits']/$sCat0['hits'], self::CAT1_FREQ_W2P);
        $h_k2 = self::CAT2_W * self::$CAT2_FREQ_N * pow($sCat2['hits']/$sCat0['hits'], self::CAT2_FREQ_W2P);
        $h_k3 = self::CAT3_W * self::$CAT3_FREQ_N * pow($sCat3['hits']/$sCat0['hits'], self::CAT3_FREQ_W2P);
        $sCat3['HITS_W'] = ($h_k0*$sCat0['hits_avg'] + $h_k1*$sCat1['hits_avg'] + $h_k2*$sCat2['hits_avg'] + $h_k3*$sCat3['hits_avg']) / ($h_k0+$h_k1+$h_k2+$h_k3); // Final Weighted average hits per product

        // for leads :
        $l_k0 = self::GLOBAL_W;
        $l_k1 = self::CAT1_W * self::$CAT1_FREQ_N * pow($sCat1['leads']/$sCat0['leads'], self::CAT1_FREQ_W2P);
        $l_k2 = self::CAT2_W * self::$CAT2_FREQ_N * pow($sCat2['leads']/$sCat0['leads'], self::CAT2_FREQ_W2P);
        $l_k3 = self::CAT3_W * self::$CAT3_FREQ_N * pow($sCat3['leads']/$sCat0['leads'], self::CAT3_FREQ_W2P);
        $sCat3['LEADS_W'] = ($l_k0*$sCat0['leads_avg'] + $l_k1*$sCat1['leads_avg'] + $l_k2*$sCat2['leads_avg'] + $l_k3*$sCat3['leads_avg']) / ($l_k0+$l_k1+$l_k2+$l_k3); // Final Weighted average leads per product

        // for orders :
        $o_k0 = self::GLOBAL_W;
        $o_k1 = self::CAT1_W * self::$CAT1_FREQ_N * pow($sCat1['orders']/$sCat0['orders'], self::CAT1_FREQ_W2P);
        $o_k2 = self::CAT2_W * self::$CAT2_FREQ_N * pow($sCat2['orders']/$sCat0['orders'], self::CAT2_FREQ_W2P);
        $o_k3 = self::CAT3_W * self::$CAT3_FREQ_N * pow($sCat3['orders']/$sCat0['orders'], self::CAT3_FREQ_W2P);
        $sCat3['ORDERS_W'] = ($o_k0*$sCat0['orders_avg'] + $o_k1*$sCat1['orders_avg'] + $o_k2*$sCat2['orders_avg'] + $o_k3*$sCat3['orders_avg']) / ($o_k0+$o_k1+$o_k2+$o_k3); // Final Weighted average orders per product

        // for hits per day :
        $sCat3['HPD_W'] = ($h_k0*$sCat0['hpd_avg'] + $h_k1*$sCat1['hpd_avg'] + $h_k2*$sCat2['hpd_avg'] + $h_k3*$sCat3['hpd_avg']) / ($h_k0+$h_k1+$h_k2+$h_k3); // Final Weighted average hitsPerDay per product

        /*print "<br/>\n<br/>\n";
        print $xmlCat1->getAttribute("name") . " | " . $xmlCat2->getAttribute("name") . " | " . $xmlCat3->getAttribute("name") . "<br/>\n";
        print "global_hits_avg = " . $sCat0['hits_avg'] . "<br/>\n";
        print "cat1_hits_avg = " . $sCat1['hits_avg'] . "<br/>\n";
        print "cat2_hits_avg = " . $sCat2['hits_avg'] . "<br/>\n";
        print "cat3_hits_avg = " . $sCat3['hits_avg'] . "<br/>\n";
        print "h_k0 = " . $h_k0 . "<br/>\n";
        print "h_k1 = " . $h_k1 . "<br/>\n";
        print "h_k2 = " . $h_k2 . "<br/>\n";
        print "h_k3 = " . $h_k3 . "<br/>\n";
        print "sCat3['HITS_W'] = " . $sCat3['HITS_W'] . "<br/>\n";
        print "sCat3['LEADS_W'] = " . $sCat3['LEADS_W'] . "<br/>\n";
        print "sCat3['ORDERS_W'] = " . $sCat3['ORDERS_W'] . "<br/>\n";
        print "sCat3['HPD_W'] = " . $sCat3['HPD_W'] . "<br/>\n";
        print "<br/>\n<br/>\n";*/

        // free cat1/cat2 ref
        unset($sCat1, $sCat2);
      }

      // Computing product selling score
      $pdt['score2'] = (
          $pdt['hits2leads'] * $sCat3['HITS_W']/$sCat3['LEADS_W'] * self::HITS2LEADS_W +
          $pdt['hits2orders'] * $sCat3['HITS_W']/$sCat3['ORDERS_W'] * self::HITS2ORDERS_W)
        * pow($pdt['hits']/$sCat3['HITS_W'], self::HITS_FREQ_W2P)
        * pow($pdt['hpd']/$sCat3['HPD_W'], self::HITS_DAY_FREQ_W2P);

      // free cat2 ref
      unset($sCat3);

    }
    unset($pdt);

  }

  public static function getRelatedProducts($pdtId, $n = self::SHOWN_PRODUCTS_RELATED_COUNT) {
    // 2 way to load the related product
    // first is the doctrine classical way, which is slow without apc, so we only use it if the hydrator was loaded
    $rPdtList = array();
    if (class_exists("Doctrine_Hydrator", false)) {
      $rPdtList = Doctrine_Query::create()
          ->select('pr.id,
                    p.id,
                    pfr.ref_name AS ref_name,
                    pfr.name AS name,
                    pfr.fastdesc AS fastdesc,
                    pfr.descc AS descc')
          ->from('Products p')
          ->innerJoin('p.products_related_to prt')
          ->innerJoin('p.product_fr pfr')
          ->innerJoin('p.advertiser a')
          ->where('prt.pdt_id = ?', $pdtId)
          ->andWhere('a.actif = ?', 1)
          ->andWhere('pfr.active = ?', 1)
          ->andWhere('pfr.deleted = ?', 0)
          ->orderBy('prt.rank', 'ASC')
          ->limit($n)
          ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);

    // second is the PDO way, not very nice but very fast. Mainly used for the front office product cart where Doctrine Query is not used
    } else {
      global $conn;
      $dbh = $conn->getDbh();
      $sth = $dbh->prepare("
        SELECT
          p.id,
          pfr.ref_name,
          pfr.name,
          pfr.fastdesc,
          pfr.descc
        FROM products p
        INNER JOIN products_related pr ON pr.pdt_related_id = p.id
        INNER JOIN products_fr pfr ON pfr.id = p.id AND pfr.active = 1 AND pfr.deleted = 0
        INNER JOIN advertisers a ON a.id = p.idAdvertiser AND a.actif = 1
        WHERE pr.pdt_id = :pdtId
        ORDER BY pr.rank ASC");
      $sth->execute(array(':pdtId' => $pdtId));
      while ($pdt = $sth->fetch(PDO::FETCH_ASSOC))
        $rPdtList[] = $pdt;
    }
    return $rPdtList;
  }

  public static function getNewRelatedProducts($PdtIdList2I, $catId, $n = self::SHOWN_PRODUCTS_RELATED_COUNT, $u = self::PERTAINED_PRODUCTS_RELATED_COUNT) {
    $catPdtList = Doctrine_Query::create()
        ->select('p.id,
                  f.id AS catID,
                  pfr.ref_name AS ref_name,
                  pfr.name AS name,
                  pfr.fastdesc AS fastdesc,
                  pfr.descc AS descc,
                  ps.hits AS hits,
                  ps.leads AS leads,
                  ps.orders AS orders,
                  ps.first_hit_time AS first_hit_time')
        ->from('Products p')
        ->innerJoin('p.product_fr pfr')
        ->innerJoin('p.advertiser a')
        ->innerJoin('p.product_stats ps')
        ->innerJoin('p.families f')
        ->where('f.id = ?', $catId)
        ->andWhere('pfr.active = ?', 1)
        ->andWhere('pfr.deleted = ?', 0)
        ->andWhere('a.actif = ?', 1)
        ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);
    self::setProductsPerformanceScore($catPdtList);
    Utils::sortDbInPlace($catPdtList, "score2", SORT_DESC, SORT_NUMERIC, "id", SORT_ASC, SORT_NUMERIC);
    $catPdtList = array_slice($catPdtList, 0, $u);

    $PdtIdList2I = array_flip($PdtIdList2I);

    foreach ($catPdtList as $k => $pdt) {
      if (isset($PdtIdList2I[$pdt['id']]))
        unset ($catPdtList[$k]);
    }

    shuffle($catPdtList);
    $catPdtList = array_slice($catPdtList, 0, $n);
    return $catPdtList;
  }

  public static function setRelatedProducts($pdtId, $rPdtIds) {
    $rows = Doctrine_Query::create()
      ->delete('ProductsRelated pr')
      ->where('pr.pdt_id = ?', $pdtId)
      ->execute();

    $prc = new Doctrine_Collection('ProductsRelated');
    foreach ($rPdtIds as $k => $rPdtId) {
      $prc[$k]->pdt_id = $pdtId;
      $prc[$k]->pdt_related_id = $rPdtId;
      $prc[$k]->rank = $k+1;
    }
    $prc->save();
  }

  public static function getLinkedProducts($pdtId) {
    // same 2 way loading as for the related products
    $lPdtList = array();
    /*if (class_exists("Doctrine_Hydrator", false)) {
      $lPdtList = Doctrine_Query::create()
          ->select('pr.id,
                    p.id,
                    pfr.ref_name AS ref_name,
                    pfr.name AS name,
                    f.id AS cat_id')
          ->from('Products p')
          ->innerJoin('p.products_linked_to plt')
          ->innerJoin('p.product_fr pfr')
          ->innerJoin('p.families f')
          ->innerJoin('p.advertiser a')
          ->where('plt.pdt_id = ?', $pdtId)
          ->andWhere('a.actif = ?', 1)
          ->andWhere('pf.orderFamily =< ?', 1)
          ->andWhere('pfr.active = ?', 1)
          ->andWhere('pfr.deleted = ?', 0)
          ->groupBy('p.id')
          ->orderBy('plt.position', 'ASC')
          ->execute(array(), Doctrine_Core::HYDRATE_ARRAY);
    } else {*/
      global $conn;
      $dbh = $conn->getDbh();
      $sth = $dbh->prepare("
        SELECT
          p.id,
          pfr.ref_name,
          pfr.name,
          pf.idFamily AS cat_id
        FROM products p
        INNER JOIN products_linked pl ON pl.pdt_linked_id = p.id
        INNER JOIN products_fr pfr ON pfr.id = p.id AND pfr.active = 1 AND pfr.deleted = 0
        INNER JOIN products_families pf ON pf.idProduct = p.id
        INNER JOIN advertisers a ON a.id = p.idAdvertiser AND a.actif = 1
        WHERE
          pl.pdt_id = :pdtId AND
          pf.orderFamily <= 1
        GROUP BY p.id
        ORDER BY pl.position ASC");
      $sth->execute(array(':pdtId' => $pdtId));
      while ($pdt = $sth->fetch(PDO::FETCH_ASSOC))
        $lPdtList[] = $pdt;
    //}
    return $lPdtList;
  }
}
